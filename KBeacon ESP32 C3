#include <WiFi.h>
#include <WebServer.h>
#include <esp_wifi.h>
#include <vector>
#include <ESPmDNS.h>
#include <DNSServer.h>
#include <Preferences.h>

WebServer server(80);
DNSServer dnsServer;
Preferences preferences;

// DNS and hostname settings
const byte DNS_PORT = 53;
const char* HOSTNAME = "KBeacon";  // This will be used for KBeacon.local

// Configuration variables
String beaconMessage = "KBeacon";
String listMessages = ""; // For storing comma-separated SSIDs
bool broadcasting = false;
bool isVariationMode = true; // true = variation mode, false = list mode
const int maxBeaconsPerChannel = 50;
const int variationsPerBeacon = 50;  // 50 variations
uint8_t beaconPacket[128];
uint8_t macAddr[6];

// WiFi settings
String current_ap_ssid = "KBeacon";    // Default value
String current_ap_password = "KBpass123"; // Default value

// Built-in LED for status (GPIO8 on ESP32-C3 SuperMini - inverted logic)
const int LED_PIN = 8;

// Array of symbols and spaces for variations
const char* symbols[] = {
    ".",          // Period
    "_",          // Underscore
    " ",          // Space
    "  ",         // Double space
    "   ",        // Triple space
    "..",         // Double period
    "__",         // Double underscore
    ". ",         // Period space
    " .",         // Space period
    "_ ",         // Underscore space
    " _"          // Space underscore
};

const char* spaces[] = {
    "",           // No space
    " ",          // Single space
    "  ",         // Double space
    "   ",        // Triple space
    ".",          // Period
    "_"           // Underscore
};

std::vector<String> customSSIDs; // Store parsed SSIDs for list mode

// HTML for the configuration page with both modes
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <title>KBeacon Spammer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial; padding: 20px; }
        .button { 
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .stop { background-color: #f44336; }
        .mode-btn { background-color: #2196F3; }
        input[type=text], textarea {
            padding: 8px;
            margin: 8px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%%;
            max-width: 300px;
        }
        .mode-container {
            border: 1px solid #ddd;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            background: %s;
        }
    </style>
</head>
<body>
    <h2>KBeacon Spammer</h2>
    
    <div class="mode-container" style="background: %s">
        <h3>Mode 1: Variation Broadcasting</h3>
        <form action="/update" method="POST">
            <label>Base Message (will create 50 variations):</label><br>
            <input type="text" name="message" value="%s"><br>
            <input type="hidden" name="mode" value="variation">
            <input type="submit" class="button" value="Update Message">
        </form>
    </div>

    <div class="mode-container" style="background: %s">
        <h3>Mode 2: Custom List Broadcasting</h3>
        <form action="/update" method="POST">
            <label>Custom SSIDs (comma-separated):</label><br>
            <textarea name="list" rows="4">%s</textarea><br>
            <input type="hidden" name="mode" value="list">
            <input type="submit" class="button" value="Update List">
        </form>
    </div>

    <div class="mode-container">
        <h3>WiFi Access Point Settings</h3>
        <form action="/updatewifi" method="POST">
            <label>Access Point Name:</label><br>
            <input type="text" name="ap_ssid" value="%s"><br>
            <label>Password (minimum 8 chars):</label><br>
            <input type="text" name="ap_password" value="%s"><br>
            <input type="submit" class="button" value="Update WiFi Settings">
        </form>
        <p><small>Note: Device will restart after updating WiFi settings</small></p>
    </div>

    <br>
    <form action="/switchmode" method="POST">
        <input type="submit" class="button mode-btn" value="Switch to %s Mode">
    </form>
    <br>
    <a href="/toggle"><button class="button %s">%s Broadcasting</button></a>
    
    <p>Status: %s</p>
    <p>Current Mode: %s</p>
    <p>Broadcasting: %s</p>
    <p>Connected devices: %d</p>
    <p><small>Last updated: %lu ms ago</small></p>
</body>
</html>
)rawliteral";

// Basic utility functions
void blinkLED(int times, int delayTime = 100) {
    for(int i = 0; i < times; i++) {
        digitalWrite(LED_PIN, LOW);  // ON (inverted logic)
        delay(delayTime);
        digitalWrite(LED_PIN, HIGH); // OFF (inverted logic)
        delay(delayTime);
    }
}

// Split comma-separated string into vector of SSIDs
void parseSSIDList(String list) {
    customSSIDs.clear();
    int start = 0;
    int end = list.indexOf(',');
    while (end >= 0) {
        String ssid = list.substring(start, end);
        ssid.trim();
        if (ssid.length() > 0 && ssid.length() <= 32) {
            customSSIDs.push_back(ssid);
        }
        start = end + 1;
        end = list.indexOf(',', start);
    }
    String lastSSID = list.substring(start);
    lastSSID.trim();
    if (lastSSID.length() > 0 && lastSSID.length() <= 32) {
        customSSIDs.push_back(lastSSID);
    }
}

void generateRandomMac(uint8_t* mac) {
    for(int i = 0; i < 6; i++) {
        mac[i] = random(256);
    }
    mac[0] |= 0x02;  // Set locally administered bit
    mac[0] &= 0xFE;  // Ensure unicast bit
}

void createBeaconPacket(const String& ssid) {
    // Beacon packet structure setup
    uint8_t packet[128] = {
        0x80, 0x00,             // Frame Control
        0x00, 0x00,             // Duration
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,   // Destination address
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Source address
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // BSSID
        0x00, 0x00,             // Sequence number
        // Fixed parameters
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Timestamp
        0x64, 0x00,             // Beacon interval
        0x11, 0x00,             // Capability info
        // SSID
        0x00                    // SSID parameter set
    };

    // Clear buffer and copy packet header
    memset(beaconPacket, 0, sizeof(beaconPacket));
    memcpy(beaconPacket, packet, sizeof(packet));
    
    // Set random MAC address
    generateRandomMac(macAddr);
    memcpy(&beaconPacket[10], macAddr, 6);
    memcpy(&beaconPacket[16], macAddr, 6);
    
    // Set SSID
    beaconPacket[36] = 0x00;  // SSID parameter set
    beaconPacket[37] = ssid.length();  // SSID length
    memcpy(&beaconPacket[38], ssid.c_str(), ssid.length());
}

String createVariation(int index) {
    int spaceIndex = index % 6;  // 6 space variations
    int symbolIndex = (index / 6) % 11;  // 11 symbols
    return beaconMessage + spaces[spaceIndex] + symbols[symbolIndex];
}

void broadcastBeacon() {
    if (!broadcasting) return;
    
    static unsigned long lastStatusPrint = 0;
    static unsigned long lastLedToggle = 0;
    const unsigned long STATUS_PRINT_INTERVAL = 5000;
    const unsigned long LED_TOGGLE_INTERVAL = 100;
    
    // Channels to broadcast on
    int channels[] = {1, 6, 11};
    
    if (isVariationMode) {
        // Variation Mode: Create variations of base message
        for (int ch = 0; ch < 3; ch++) {
            esp_wifi_set_channel(channels[ch], WIFI_SECOND_CHAN_NONE);
            
            for (int i = 0; i < variationsPerBeacon; i++) {
                String variation = createVariation(i);
                createBeaconPacket(variation);
                int packetSize = 38 + variation.length();
                
                for (int j = 0; j < maxBeaconsPerChannel; j++) {
                    esp_wifi_80211_tx(WIFI_IF_AP, beaconPacket, packetSize, false);
                    delayMicroseconds(10);
                }
            }
        }
    } else {
        // List Mode: Broadcast each SSID from the list
        for (int ch = 0; ch < 3; ch++) {
            esp_wifi_set_channel(channels[ch], WIFI_SECOND_CHAN_NONE);
            
            for (const String& ssid : customSSIDs) {
                createBeaconPacket(ssid);
                int packetSize = 38 + ssid.length();
                
                for (int j = 0; j < maxBeaconsPerChannel; j++) {
                    esp_wifi_80211_tx(WIFI_IF_AP, beaconPacket, packetSize, false);
                    delayMicroseconds(10);
                }
            }
        }
    }
    
    // Visual feedback
    if (millis() - lastLedToggle >= LED_TOGGLE_INTERVAL) {
        digitalWrite(LED_PIN, !digitalRead(LED_PIN));
        lastLedToggle = millis();
    }
    
    // Status printing
    if (millis() - lastStatusPrint >= STATUS_PRINT_INTERVAL) {
        if (isVariationMode) {
            Serial.printf("Broadcasting %d variations of '%s'\n", 
                         variationsPerBeacon, beaconMessage.c_str());
        } else {
            Serial.printf("Broadcasting %d custom SSIDs\n", 
                         customSSIDs.size());
        }
        lastStatusPrint = millis();
    }
}

void handleRoot() {
    char temp[4000];
    String activeColor = "rgba(144, 238, 144, 0.2)";  // Light green
    String inactiveColor = "rgba(220, 220, 220, 0.2)"; // Light gray
    
    snprintf(temp, sizeof(temp), index_html, 
             isVariationMode ? activeColor.c_str() : inactiveColor.c_str(),
             isVariationMode ? activeColor.c_str() : inactiveColor.c_str(),
             beaconMessage.c_str(),
             !isVariationMode ? activeColor.c_str() : inactiveColor.c_str(),
             listMessages.c_str(),
             current_ap_ssid.c_str(),
             current_ap_password.c_str(),
             isVariationMode ? "List" : "Variation",
             broadcasting ? "stop" : "",
             broadcasting ? "Stop" : "Start",
             broadcasting ? "ACTIVE" : "STOPPED",
             isVariationMode ? "Variation" : "List",
             isVariationMode ? String(String(variationsPerBeacon) + " variations of '" + beaconMessage + "'").c_str() 
                           : String(String(customSSIDs.size()) + " custom SSIDs").c_str(),
             WiFi.softAPgetStationNum(),
             millis());
             
    server.send(200, "text/html", temp);
}

void handleUpdate() {
    if (server.hasArg("mode")) {
        String mode = server.arg("mode");
        if (mode == "variation" && server.hasArg("message")) {
            beaconMessage = server.arg("message");
            isVariationMode = true;
            Serial.printf("Updated to variation mode with message: %s\n", beaconMessage.c_str());
        } else if (mode == "list" && server.hasArg("list")) {
            listMessages = server.arg("list");
            parseSSIDList(listMessages);
            isVariationMode = false;
            Serial.printf("Updated to list mode with %d SSIDs\n", customSSIDs.size());
        }
    }
    server.sendHeader("Location", "/");
    server.send(303);
}

void handleUpdateWifi() {
    if (server.hasArg("ap_ssid") && server.hasArg("ap_password")) {
        String new_ssid = server.arg("ap_ssid");
        String new_password = server.arg("ap_password");
        
        // Validate inputs
        if (new_ssid.length() < 1 || new_password.length() < 8) {
            server.send(400, "text/plain", "SSID and password must be at least 1 and 8 characters respectively");
            return;
        }
        
        // Save to preferences
        preferences.begin("wifi-config", false);
        preferences.putString("ap_ssid", new_ssid);
        preferences.putString("ap_password", new_password);
        preferences.end();
        
        // Send response before restarting
        server.send(200, "text/plain", "WiFi settings updated. Device restarting...");
        delay(2000);
        
        // Restart ESP32
        ESP.restart();
    }
}

void handleSwitchMode() {
    isVariationMode = !isVariationMode;
    Serial.printf("Switched to %s mode\n", isVariationMode ? "variation" : "list");
    server.sendHeader("Location", "/");
    server.send(303);
}

void handleToggle() {
    broadcasting = !broadcasting;
    Serial.printf("Broadcasting %s\n", broadcasting ? "started" : "stopped");
    
    if (broadcasting) {
        blinkLED(4);
    } else {
        blinkLED(2);
        digitalWrite(LED_PIN, HIGH);
    }
    
    server.sendHeader("Location", "/");
    server.send(303);
}

void handleNotFound() {
    // For captive portal - redirect all requests to the main page
    server.sendHeader("Location", String("http://") + WiFi.softAPIP().toString(), true);
    server.send(302, "text/plain", "");
}

void setup() {
    randomSeed(esp_random());
    Serial.begin(115200);
    
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, HIGH);
    
    delay(3000);
    
    Serial.println("\n\n=== KBeacon Spammer Starting ===");
    Serial.println("Board: ESP32-C3 SuperMini");
    Serial.println("SDK Version: " + String(ESP.getSdkVersion()));
    Serial.println("CPU Freq: " + String(ESP.getCpuFreqMHz()) + "MHz");
    Serial.println("Free Heap: " + String(ESP.getFreeHeap()));

    // Load saved WiFi settings if they exist
    preferences.begin("wifi-config", false);
    current_ap_ssid = preferences.getString("ap_ssid", "KBeacon");
    current_ap_password = preferences.getString("ap_password", "KBpass123");
    preferences.end();
    
    // Initialize WiFi
    WiFi.disconnect();
    WiFi.mode(WIFI_AP);
    esp_wifi_set_mode(WIFI_MODE_AP);
    
    if(WiFi.softAP(current_ap_ssid.c_str(), current_ap_password.c_str(), 6)) {
        Serial.println("✓ WiFi Access Point Created Successfully");
        Serial.println("  SSID: " + current_ap_ssid);
        Serial.println("  Password: " + current_ap_password);
        Serial.println("  AP IP: " + WiFi.softAPIP().toString());
        blinkLED(3);
    } else {
        Serial.println("✗ Failed to create WiFi Access Point!");
        while(1) {
            blinkLED(5, 50);  // Rapid blinking indicates error
            delay(500);
        }
    }

    // Start mDNS responder
    if(MDNS.begin(HOSTNAME)) {
        Serial.println("✓ mDNS responder started");
        Serial.println("  You can access the web interface at:");
        Serial.println("  http://" + String(HOSTNAME) + ".local");
    } else {
        Serial.println("✗ Error setting up mDNS responder!");
    }

    // Configure captive portal
    dnsServer.start(DNS_PORT, "*", WiFi.softAPIP());
    Serial.println("✓ Captive portal started");

    // Setup web server with all handlers
    server.onNotFound(handleNotFound);  // For captive portal
    server.on("/", handleRoot);
    server.on("/update", handleUpdate);
    server.on("/updatewifi", handleUpdateWifi);
    server.on("/switchmode", handleSwitchMode);
    server.on("/toggle", handleToggle);
    server.begin();
    
    Serial.println("✓ Web server started");
    Serial.println("=== Setup Complete! ===");
    Serial.println("Connect to WiFi network '" + current_ap_ssid + "'");
    Serial.println("Access methods:");
    Serial.println("1. http://" + WiFi.softAPIP().toString());
    Serial.println("2. http://" + String(HOSTNAME) + ".local");
    Serial.println("3. Or connect to WiFi and wait for captive portal");
    
    // Final success indication
    blinkLED(5, 200);
}

void loop() {
    // Handle DNS requests for captive portal
    dnsServer.processNextRequest();
    
    // Handle web server clients
    server.handleClient();
    
    // Handle beacon broadcasting
    broadcastBeacon();
    
    // Print connected clients periodically
    static unsigned long lastClientCheck = 0;
    if (millis() - lastClientCheck >= 10000) { // Every 10 seconds
        if (WiFi.softAPgetStationNum() > 0) {
            Serial.printf("Connected clients: %d\n", WiFi.softAPgetStationNum());
        }
        lastClientCheck = millis();
    }
}
